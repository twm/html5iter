from __future__ import absolute_import, division, unicode_literals

import io
from xml.etree import ElementTree

from . import support  # noqa

from html5lib.constants import namespaces
from html5lib import parse, parseFragment, HTMLParser


# tests that aren't autogenerated from text files
def test_assertDoctypeCloneable():
    doc = parse('<!DOCTYPE HTML>', treebuilder="dom")
    assert doc.cloneNode(True) is not None


def test_line_counter():
    # http://groups.google.com/group/html5lib-discuss/browse_frm/thread/f4f00e4a2f26d5c0
    assert parse("<pre>\nx\n&gt;\n</pre>") is not None


def test_namespace_html_elements_0_dom():
    doc = parse("<html></html>",
                treebuilder="dom",
                namespaceHTMLElements=True)
    assert doc.childNodes[0].namespaceURI == namespaces["html"]


def test_namespace_html_elements_1_dom():
    doc = parse("<html></html>",
                treebuilder="dom",
                namespaceHTMLElements=False)
    assert doc.childNodes[0].namespaceURI is None


def test_namespace_html_elements_0_etree():
    [root] = parse("<html></html>", treebuilder="etree", namespaceHTMLElements=True)
    assert root.tag == "{%s}html" % (namespaces["html"],)


def test_namespace_html_elements_1_etree():
    [root] = parse("<html></html>", treebuilder="etree", namespaceHTMLElements=False)
    assert root.tag == "html"


def test_parse_etree():
    """
    Parsing a fragment to an etree produces a document root element that
    contains the document, including implied tags.
    """
    doc = parse(
        "<!DOCTYPE html><html><title>...</title><p>...</p></html><!-- ... -->",
        treebuilder="etree",
    )
    assert doc.tag == 'DOCUMENT_ROOT'
    [doctype, html, comment] = doc
    assert doctype.tag == "<!DOCTYPE>"
    assert doctype.text == "html"
    assert html.tag == "{http://www.w3.org/1999/xhtml}html"
    assert comment.tag is ElementTree.Comment
    assert comment.text == " ... "
    [head, body] = html
    assert head.tag == "{http://www.w3.org/1999/xhtml}head"
    assert body.tag == "{http://www.w3.org/1999/xhtml}body"
    [title] = head
    assert title.tag == "{http://www.w3.org/1999/xhtml}title"
    [p] = body
    assert p.tag == "{http://www.w3.org/1999/xhtml}p"
    assert p.text == "..."


def test_parse_fragment_etree():
    """
    Parsing a fragment to to an etree produces a fragment root element that
    directly contains the given HTML.
    """
    fragment = parseFragment("<p>...</p>", treebuilder="etree")
    assert fragment.tag == 'DOCUMENT_FRAGMENT'
    [p] = fragment
    assert p.tag == "{http://www.w3.org/1999/xhtml}p"
    assert p.text == "..."


def test_unicode_file():
    assert parse(io.StringIO("a")) is not None


def test_debug_log():
    parser = HTMLParser(debug=True)
    parser.parse("<!doctype html><title>a</title><p>b<script>c</script>d</p>e")

    expected = [('dataState', 'InitialPhase', 'InitialPhase', 'processDoctype', {'type': 'Doctype'}),
                ('dataState', 'BeforeHtmlPhase', 'BeforeHtmlPhase', 'processStartTag', {'name': 'title', 'type': 'StartTag'}),
                ('dataState', 'BeforeHeadPhase', 'BeforeHeadPhase', 'processStartTag', {'name': 'title', 'type': 'StartTag'}),
                ('dataState', 'InHeadPhase', 'InHeadPhase', 'processStartTag', {'name': 'title', 'type': 'StartTag'}),
                ('rcdataState', 'TextPhase', 'TextPhase', 'processCharacters', {'type': 'Characters'}),
                ('dataState', 'TextPhase', 'TextPhase', 'processEndTag', {'name': 'title', 'type': 'EndTag'}),
                ('dataState', 'InHeadPhase', 'InHeadPhase', 'processStartTag', {'name': 'p', 'type': 'StartTag'}),
                ('dataState', 'AfterHeadPhase', 'AfterHeadPhase', 'processStartTag', {'name': 'p', 'type': 'StartTag'}),
                ('dataState', 'InBodyPhase', 'InBodyPhase', 'processStartTag', {'name': 'p', 'type': 'StartTag'}),
                ('dataState', 'InBodyPhase', 'InBodyPhase', 'processCharacters', {'type': 'Characters'}),
                ('dataState', 'InBodyPhase', 'InBodyPhase', 'processStartTag', {'name': 'script', 'type': 'StartTag'}),
                ('dataState', 'InBodyPhase', 'InHeadPhase', 'processStartTag', {'name': 'script', 'type': 'StartTag'}),
                ('scriptDataState', 'TextPhase', 'TextPhase', 'processCharacters', {'type': 'Characters'}),
                ('dataState', 'TextPhase', 'TextPhase', 'processEndTag', {'name': 'script', 'type': 'EndTag'}),
                ('dataState', 'InBodyPhase', 'InBodyPhase', 'processCharacters', {'type': 'Characters'}),
                ('dataState', 'InBodyPhase', 'InBodyPhase', 'processEndTag', {'name': 'p', 'type': 'EndTag'}),
                ('dataState', 'InBodyPhase', 'InBodyPhase', 'processCharacters', {'type': 'Characters'})]

    assert parser.log == expected


def test_no_duplicate_clone():
    frag = parseFragment("<b><em><foo><foob><fooc><aside></b></em>")
    assert len(frag) == 2


def test_self_closing_col():
    parser = HTMLParser()
    parser.parseFragment('<table><colgroup><col /></colgroup></table>')
    assert not parser.errors
